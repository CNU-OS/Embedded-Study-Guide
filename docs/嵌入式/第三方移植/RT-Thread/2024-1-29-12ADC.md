# ADC

rt_thread已经实现了ADC的驱动, 可以直接使用接口进行使用

| **函数**         | **描述**                              |
| ---------------- | ------------------------------------- |
| rt_device_find() | 根据 ADC 设备名称查找设备获取设备句柄 |
| rt_adc_enable()  | 使能 ADC 设备                         |
| rt_adc_read()    | 读取 ADC 设备数据                     |
| rt_adc_disable() | 关闭 ADC 设备                         |

> 一般情况下，注册到系统的 ADC 设备名称为 adc0，adc1

## 接口

## 获取

```c
rt_err_t rt_adc_enable(rt_adc_device_t dev, rt_uint32_t channel);
```

> | **参数**   | **描述**               |
> | ---------- | ---------------------- |
> | dev        | ADC 设备句柄           |
> | channel    | ADC 通道               |
> | **返回**   | ——                     |
> | RT_EOK     | 成功                   |
> | -RT_ENOSYS | 失败，设备操作方法为空 |
> | 其他错误码 | 失败                   |

### 使能

```c
rt_err_t rt_adc_enable(rt_adc_device_t dev, rt_uint32_t channel);
```

> | **参数**   | **描述**               |
> | ---------- | ---------------------- |
> | dev        | ADC 设备句柄           |
> | channel    | ADC 通道               |
> | **返回**   | ——                     |
> | RT_EOK     | 成功                   |
> | -RT_ENOSYS | 失败，设备操作方法为空 |
> | 其他错误码 | 失败                   |

### 读取

```c
rt_uint32_t rt_adc_read(rt_adc_device_t dev, rt_uint32_t channel);
```

> |            |              |
> | ---------- | ------------ |
> | **参数**   | **描述**     |
> | dev        | ADC 设备句柄 |
> | channel    | ADC 通道     |
> | **返回**   | ——           |
> | 读取的数值 |              |

### 关闭通道

```c
rt_err_t rt_adc_disable(rt_adc_device_t dev, rt_uint32_t channel);
```

> | **参数**   | **描述**               |
> | ---------- | ---------------------- |
> | dev        | ADC 设备句柄           |
> | channel    | ADC 通道               |
> | **返回**   | ——                     |
> | RT_EOK     | 成功                   |
> | -RT_ENOSYS | 失败，设备操作方法为空 |
> | 其他错误码 | 失败                   |

## Finsh命令

在使用设备前，需要先查找设备是否存在，可以使用命令 `adc probe` 后面跟注册的 ADC 设备的名称。

```bash
msh >adc probe adc1
probe adc1 success
```

可以使用命令进行使能

```bash
msh >adc enable 5
adc1 channel 5 enables success
```

使用命令进行读取

```c
msh >adc read 5
adc1 channel 5  read value is 0x00000FFF
msh >
```

关闭

```bash
msh >adc disable 5
adc1 channel 5 disable success
msh >
```

## 实际的使用

```c
/** if you want to use adc you can use the following instructions.
 *
 * STEP 1, open adc driver framework support in the RT-Thread Settings file
 *
 * STEP 2, define macro related to the adc
 *                 such as     #define BSP_USING_ADC1
 *
 * STEP 3, copy your adc init function from stm32xxxx_hal_msp.c generated by stm32cubemx to the end of board.c file
 *                 such as     void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
 *
 * STEP 4, modify your stm32xxxx_hal_config.h file to support adc peripherals. define macro related to the peripherals
 *                 such as     #define HAL_ADC_MODULE_ENABLED
 *
 */

/*#define BSP_USING_ADC1*/
/*#define BSP_USING_ADC2*/
/*#define BSP_USING_ADC3*/
```

![image-20240129221820103](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401292218160.png)

![image-20240129223630892](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401292236962.png)

<img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401301427170.png"/>

![image-20240129223616174](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401292236225.png)

### 使用的代码

```c
#include <rtthread.h>

#define DBG_TAG "main"
#define DBG_LVL DBG_LOG
#include <rtdbg.h>
#include <rtdevice.h>

rt_adc_device_t dev;
rt_thread_t adc_thread;
void adc_deal(void *parameter)
{
    rt_uint32_t adc_data;
    while(1){
        adc_data = rt_adc_read(dev, 11);

        rt_kprintf("data = %d, real value = %f \n", adc_data, adc_data*3.3/4096);
        rt_thread_mdelay(2000);
    }
}
int main(void)
{
    rt_err_t ret;
    dev = (rt_adc_device_t)rt_device_find("adc1");
    if(dev == RT_NULL){
        LOG_E("adc_find err...\n");
        return -EINVAL;
    }

    ret = rt_adc_enable(dev, 11);
    if(ret < 0)
    {
        LOG_E("adc_open err..\n");
        return ret;
    }
    adc_thread = rt_thread_create("adc_thread", adc_deal, RT_NULL, 1024, 18, 20);
    rt_thread_startup(adc_thread);
    return 0;
}

```

### 串口

![image-20240130143247962](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401301432001.png)

