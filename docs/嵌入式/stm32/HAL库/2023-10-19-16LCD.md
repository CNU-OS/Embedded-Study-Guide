# LCD

图像的颜色是使用RGB进行控制

HSV和HLS颜色空间适用于图形处理, 包括色调, 饱和度等设置

LCD主要是通过施加电压来控制通过不同颜色的滤光片的颜色的多少, 电压可以改变液晶的偏转角度, 背光发射的光是白光, 经过滤光之后显示不同的颜色, LCD所有的像素使用同一个背光

OLED有机自发光二极管, 通过特殊设计的发光二极管, 控制不同颜色的二极管的颜色明暗来进行控制显示的颜色, 每一个的光源单独控制, 在部分显示的时候OLED会更加省电, 对比度更高, 显示出来的黑色等颜色更加纯正

液晶在寒冷的时候会响应比较慢, OLED没有这个方面的问题, 并且屏幕更加的低, 但是存在问题, OLED是有机物, 老化的比较快, 会出现烧屏

调光的方式, OLED使用的是DC调光, 使用的是直接调节电压的方式, 而LCD使用的是PWM, 有可能会导致屏闪

## 显示屏控制原理

主要的参数, 像素, 分辨率, 色彩深度(显示的颜色的数量), 显示器尺寸, 屏幕的对角线的尺寸, 使用英寸进行表示, 点距

显示器的接口, DP, HDMI, DVI, VGA

MCU模式: RGB模式, SPI, 串口

一般的屏幕的组成, 液晶显示面板, 触摸面板, PCB板, PCB上面有可能有一个控制芯片, 主要是为了低级的MCU也可以控制, MCU屏幕因为有LCD驱动器不需要点.行,时钟等, 而另一种没有的则需要, 高级的芯片可以直接进行刷新板子的显示, 一般RGB屏幕一般比较大, 而MCU屏幕一般比较小, 在控制器里面有显存

+ 不使用控制器的屏幕

液晶屏与外部使用同步通讯方式，以 CLK 信号作为同步时钟，在同步时钟的驱动下， 每个时钟传输一个像素点数据。水平同步信号 HSYNC(Horizontal Sync) 用于表示液晶屏一行像素数据的传输结束，每 传输完成液晶屏的一行像素数据时，HSYNC 会发生电平跳变，如分辨率为 800x480 的显示屏 (800 列，480 行)，传输一帧的图像 HSYNC 的电平会跳变 480 次。垂直同步信号 VSYNC(Vertical Sync) 用于表示液晶屏一帧像素数据的传输结束，每传 输完成一帧像素数据时，VSYNC 会发生电平跳变。其中“帧”是图像的单位，一幅 图像称为一帧

实际上还有一些边缘的校验, 需要加上一些边沿的像素, 但是不参与显示, 主要是当你传入的数据不对的时候会显示出来

RGB LCD一般有两种驱动模式：DE模式和HV模式，这两个模式的区别是DE模式需要用到DE信号线，而HV模式不需要用到DE信号线，在DE模式下是可以不需要HSYNC信号线的，即使不接HSYNC信号线LCD也可以正常工作。

## 8080时序(RGB控制)

+ NT35510控制芯片

一般使用8080时序, 还可以使用的是SPI和I2C时序, 但是时钟速率比较低

使用一个引脚低电平为数据有效WRX, 使用另一个引脚控制是数据还是命令DCX, 一个片选引脚CSX, 读写控制引脚 RDX, 还使用了16位的数据引脚, 可以使用FSMC进行模拟

> 使用数据引脚传输数据, 使用一根数据线选择发送数据还是命令, NEx用来做CSX, NOE对应读RDX, NWE作为写WRX

> 实际写入的时候需要控制对应的引脚为0或1, 计算地址之后自动生成

## 使用CubeMX生成代码

生成之后需要手动设置一下使用的模式


### 读取时序的设置

[STM32CubeMX学习笔记（38）——FSMC接口使用（TFT-LCD屏显示） - 掘金 (juejin.cn)](https://juejin.cn/post/7135631218787221541)

> 地址给出以后多长时间可以进行读取使能**这个时间就是`ADDSET地址建立时间`**, 以及NOE变化之后多长时间会进行采样, **低电平保持的时间由`DATAST数据建立时间`**
>

### 写时序的设置

> 设置时间最小是10ns，在这个周期内WRX线处于低电平。 tdht：数据保持时间,与 twrh写控制高电平的最小时间相同,是10ns,在这个周期内WRX线处于高电平。 观察时序图，我们设置 tdst数据设置时间 为1HCLK（13.8>10）就能满足数据设置最小时间的要求,我们不需要考虑tdht数据保持时间(看上面模式B时序图,NWE变成高电平后,会持续1HCLK=13.8ns,默认满足tdht了)。

### 设置其他的引脚

复位引脚PE1, 背光引脚PD12需要单独设置, 

### 移植

添加文件

在初始化函数里面把引脚以及FSMC的初始化注释掉

### 初始化使用的数据

数据来自于厂家提供的内容

```c
#define      FSMC_Addr_ILI9341_CMD         ( ( uint32_t ) 0x60000000 )

//FSMC_Bank1_NORSRAM用于LCD数据操作的地址      
#define      FSMC_Addr_ILI9341_DATA        ( ( uint32_t ) 0x60020000 )
```

> 实际写入数据
>
> 使用16位的模式的时候由于地址偏移, 会导致实际操作的A16应该操作第17位的数字, 实际上通过地址线发送的地址是软件操控的地址>>1

### 实际的操控像素

首先打开一个窗口, 之后对里面进行填充色素数据

```c
/**
 * @brief  在ILI9341显示器上开辟一个窗口
 * @param  usX ：在特定扫描方向下窗口的起点X坐标
 * @param  usY ：在特定扫描方向下窗口的起点Y坐标
 * @param  usWidth ：窗口的宽度
 * @param  usHeight ：窗口的高度
 * @retval 无
 */
void ILI9341_OpenWindow ( uint16_t usX, uint16_t usY, uint16_t usWidth, uint16_t usHeight )
{	
	ILI9341_Write_Cmd ( CMD_SetCoordinateX ); 				 /* 设置X坐标 */
	ILI9341_Write_Data ( usX >> 8  );	 /* 先高8位，然后低8位 */
	ILI9341_Write_Data ( usX & 0xff  );	 /* 设置起始点和结束点*/
	ILI9341_Write_Data ( ( usX + usWidth - 1 ) >> 8  );
	ILI9341_Write_Data ( ( usX + usWidth - 1 ) & 0xff  );

	ILI9341_Write_Cmd ( CMD_SetCoordinateY ); 			     /* 设置Y坐标*/
	ILI9341_Write_Data ( usY >> 8  );
	ILI9341_Write_Data ( usY & 0xff  );
	ILI9341_Write_Data ( ( usY + usHeight - 1 ) >> 8 );
	ILI9341_Write_Data ( ( usY + usHeight - 1) & 0xff );
	
}
```

## 显示中英文

首先是字节编码, 最早的字符编码是ASCII编码, 但是由于只使用一个字节, 存储的数量有限

1980年我国发布的汉字编码字符集GB2312, 是一个简体汉字的字符集, 使用一到两个字符表示一个字符, 包含6763个常用汉字, 以及682个全角的非汉字组成

但是相对于整个汉字总数前还是不够看, 1995年发布的GBK字符集扩展了两万多个新汉字(包含繁体字)与符号, 兼容GB2312

2003年发布GB18030, 添加少数民族的字, 向下兼容GBK

ASCII使用一个字节, 但是汉字使用的是两个字节, 具体的区分ASCII使用127个字符也就是0x7f, 如果使用大于这一个数字的显示的就是汉字

### 标准统一

1994年ISO发布Unicode标准, 统一的二进制标准, 满足各个国家跨语言处理的要求

 有三种形式进行存储

+ UTF-8: 使用变长的方式
+ UTF-16: 两或四字节
+ UTF-32: 使用四个字节进行保存一个字符, 可以保存这一个标准中的任意一个字符

外码=>内码=> 交换码=>字形码

外码: 输入码, 平常键盘拼音输入的字母, 是一个索引码

内码: 计算机存储的二进制, 输入的汉字要转化为二进制形式, 集合叫做字符集

交换码: 国标码, 和别的计算机交换信息的时候使用的编码

字形码: 汉字字模, 二进制转化为可视化的图形, 集合叫做字库

### GB2312

实际使用的编码位是0xA1A1-FEFE, 汉字的区域是B0A1-F7FE, 原因是为了兼容ASCII, 最高位为1, 并且预留0x20个控制位

GB2312编码对收录的字符进行分区, 分为94个区, 每一个区有94个位, 一共有8836个码位

第16个区开始是汉字, 0-9是682个汉字以外的字符

10-15是空白区域没有使用

16-55是一级汉字, 按照拼音进行排序

56-87区收录3008个二级汉字, 按照部首进行排序

88-94是空白区没有使用

实际使用的时候就是: 区码加位码+A0A0, 比如''啊''是16区第一个, 就是0x1001+0xA0A0

实际在使用字模库的时候由于没有进行兼容偏移, 所以使用的是字符的在总个数的排序

Addr = (((ColdH - 0xA0 - 1)* 94) + (CodeL - 0xA0-1))\*32\*32/8

> Addr 地址偏移
>
> CodeH区码
>
> CodeL位码

## 实际移植

主要问题是在移植野火的库函数以后, 由于片选引脚使用的是软件进行控制的需要单独进行设置, 修改MSP函数
