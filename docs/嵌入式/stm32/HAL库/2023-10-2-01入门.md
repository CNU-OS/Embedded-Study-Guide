# HAL库入门

stm公司的芯片有Cotex-M3, M4, M7的芯片(F1/F4/F7/H7), 有很多不同的芯片, 基于不同的架构, 使用HAL库对于平台的移植有很好的兼容性, HAL是硬件抽象层的概念, 不需要关心底层的硬件, 开发人员不需要关心硬件实现

HAL库: 封装出来通用的接口, 大大提高代码通用性, 对于一个应用, 可以把它分为

可以把一个应用分为: 硬件层, 驱动层, 中间件以及应用

还可以使用工具CubeMX很方便的添加一些功能, 这一个组件通过HAL库与硬件进行交流, 第三方的库就是独立出来的, 同时还有一个LL库, 直接操控底层的寄存器, 追求效率的时候可以两个库一同进行开发

+ 中间件: 操作系统以及应用程序之间的连接, 为了方便应用的开发,够为一种或多种应用程序合作互通、资源共享，同时还能够为该应用程序提供相关的服务的软件。中间件是一类软件统称，而非一种软件;中间件不仅仅实现互连，还要实现应用之间的互操作。
+ LL库（Low-Level库）是针对单片机底层硬件的库，提供了对寄存器和外设的直接访问；固件库（Standard库）是基于LL库的高级库，提供了更高层次的抽象和易用性；HAL库（Hardware Abstraction Layer库）是更高级别的库，提供了跨平台的硬件抽象层，使得代码可移植性更强。
+ CubeMX: CubeMX是一款图形化配置工具，用于生成嵌入式系统的初始化代码，可以帮助开发人员快速生成代码，加快开发进程。

## 内核的差异

[Cortex-M for Beginners - 2017_CN_v3.pdf](file:///E:/a学习/1.stm/A盘（资料盘）/3-STM32官方资料/STM32F1官方手册资料/Cortex-M for Beginners - 2017_CN_v3.pdf)

### 分类

ARM有三种处理器有三个分类

应用处理器: 用于操作系统, 支持MMU(内存管理单元)

实时处理器: 多数不支持MMU, 通常有MPU, Cache 和其他针对工业应用设计的存 储器功能。

微控制器处理器: 在单片机和深度嵌入式系统市场非常 成功和受欢迎

+ Cortex内核的特点

使用的指令集比较高级, 有优秀的中断处理机制, 可以处理中断嵌套以及中断处理机制支持C语言, 反应速度快

在处理中断的时候跳转指令变为异常处理函数的起始地址

+ Cotex-M对于系统的支持

影子堆栈指针(为每一个进程使用不同的堆栈指针), 系统服务调用SVC和可挂起系统调用, Systick-24位递减计数器, MPU

+ 错误处理

使用未定义的指令, 访问非法的地址空间, 非法操作(在优先级高于SVC的中断中尝试触发SVC中断)

### 野火产品

Cortex-M3, 最精简的内核, 有完整的debug功能

Cortex-M4, 额外的指令, 用于数字处理, 还有浮点运算单元

Cortex-M7, 双精度的浮点运算, cache等进行添加

所有的Cotex内核都支持基准的编程模式, NVIC, 睡眠模式, 操作系统支持, Debug的支持

这几个内核使用的都是ARMv7的指令集

差异主要体现在指令集上面, 系统的架构是否有缓存, 主要还是性能以及能耗上面

## 认识STM32

ST: 意法半导体

M: 微电子

32: 总线的宽度

参考手册: 软件编程, 数据手册: 硬件数据

## 寄存器操控STM32的GPIO

> 主要的区别: 上下拉位置的区别

> 1. 进行保护, 防止电压过高过低, 但是是有效的, 数据手册中有推荐的电压以及电流
> 2. 输出模式的选择
> 3. 4. 实际的寄存器控制
>
> 5. 6. 7. 输入电平信号的控制

> 推挽输出模式的时候直接连接到电源的正负极, 开漏输出可以接地, 没有办法输出高电压电流, 主要是为了实现一个线与的通信方式

有两种方式进行环境的配置(启动文件)

1. 运行环境管理工具, ARM公司提供了一个标准的接口, CMSIS

> 添加一个内核控制文件, 以及一个设备启动文件

2. 从库包里面寻找

在使用HAL库的时候使用的包要是大版本的, 以0进行结尾

### 总线架构

Cortex-M3使用总线矩阵与外界进行连接, 通过总线可以把不同的外设分离开来, 由此可以独立的控制各个外设的使能与否(控制外设的时钟)

在存储器映像里面可以找到各个寄存器的位置, 之后再RCC时钟控制器的章节里面找到实际要控制的寄存器的偏移

最后在GPIO的章节里面找到要控制的模式

## 引入库编程的方式

寄存器编程开发难度大, 代码可读性差, 翻阅手册比较麻烦
