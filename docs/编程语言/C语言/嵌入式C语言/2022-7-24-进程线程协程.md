# 进程线程协程

在多进程时候不能使用全局变量，但是使用了锁、关中断等机制实现互斥反应

在Linux之中可以使用man命令查看是不是安全的函数

```
man 3 malloc
```

malloc调用了全局链表，但是通过临区实现了互斥访问，所以可以大胆调用

## 进程

Linux下的每一个程序都会被封装成一个进程，用task_struct管理，在Linux下每一个进程的内存都是独立的，所以无论一个函数是不是可重入都可以调用。

#### 进程之间通讯

使用第三方工具

+ 在每一个进程的4GB虚拟空间之中，3GB是各个进程独享，1GB内核是共享的，所以可以在内核中一片内存进行通讯
+ 磁盘是共享的，通过文件沟通
+ 共享内存，映射到同一块内存直接通讯

#### Linux工具

无名管道：有亲缘关系进程

有名管道：任意两个进程

信息量：进程间同步，包括system V信号量以及POISX信号量

消息队列：数据传输，包括system V消息队列以及POISX消息队列

共享内存：数据传输，包括system V共享内存以及POISX共享内存

信号：进程之间异步通讯

Linux新增API：signalfd、timerfd、eventfd

Socket：套接字缓冲区，不同主机，不同进程

D-BUS：桌面应用程序



## 线程

每个进程之间相互独立，不同进程要借助第三方，切换进程开销也很大

>  **线程**：一个进程之间可能有多个线程，共享代码段、数据段、地址空间、打开文件、信号处理等资源，每个线程又都有自己的单独的资源，如程序计数器、寄存器上下文、栈

> >  **问题**：出现对共享资源安全访问，线程之间同步，一般使用互斥锁、条件锁、读写锁实现对共享资源的安全访问。

> **互斥锁**：在一个线程使用的时候其他的线程不嗯使用，导会导致频繁的切换

> > 使用条件变量，等待条件满足唤醒绑定到这个变量的线程

> **读写锁**：允许多个线程同时读取，但是写的时候只允许一个进程，切禁止读操作

每个线程都有自己的上下文环境，自己的PC指针和栈

### 线程池

进程是资源分配的基本单元，线程是程序执行调度的最小单元

线程的开销除了开关锁、线程上下文切换，还有线程创建销毁

**线程池**：解决频繁使用线程，

> **实现方法**：预先创建一些线程没有任务的时候阻塞，有任务的时候分配到指定的进程

**组成**

+ 管理线程：分配任务
+ 工作线程：实际执行的
+ 任务接口：创建任务

## 协程

线程实行有一定的瓶颈，对共享的资源不再使用锁，交给程序锁，一般是使用在彼此熟悉的合作式多任务

## 总结

进程最安全，协程效率最高

在不同系统上的分类有所不同















