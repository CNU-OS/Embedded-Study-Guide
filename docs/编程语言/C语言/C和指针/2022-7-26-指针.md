# 指针

一个内存存储的信息保存的是是什么内容取决于读取的方式，由编译器来确定你定义的数据类型，如果不正确则进行报错

## 间接访问

一个指针访问他所指向的地址

> **注：**不要直接给一个没有初始化的地址赋值
>
> + 访问非法地址：终止程序
> + 访问地址没有对齐：UNIX系统总线错误
> + 位于合法的内存：出现不可预知的错误

## NULL指针

指向0，可以把它和0比较来判断是不是一个空指针，但是他的实际值可能不是0，这是一种源代码约定，对一个空指针进行求解是非法的。

**最好对没有初始值的指针初始化为NULL**

## 指针常量

直接使用*对一个整形去赋值是错误的，应该进行类型的转换

```C
* 100 = 25;//错误
* (int *)100 = 25;//正确
```

> 这种方式通常用来访问某些固定的内存地址,比如硬件接口等

## 指针的指针

```C
int a = 12;
int *b = &a;
int **c = &b;
```

## 指针的使用示例解析

```*++cp```:表示的是cp原先指向的地址之后的一个地址的内容

```*cp++```:执行顺序（1）返回现在的cp（2）cp加一（3）对原来的地址进行取值操作

```++*cp```:两个符号的结合性质都是从右到左，所以先对cp取值，然后对取到的值进行左++操作

```(*cp)++```:首先进行访问然后对结果进行++

```++*++cp```:先对cp代表内存之后的那个内存内容进行获取，然后进行加一

> **注：**在使用指针操作时对会对原数据造成破坏的数据进行备份

```C
int find_char(char **strings,int value)
{
    assert(strings != NULL);//如果结果不正确就打印一条提示
    while(*strings != NULL)
    {
        while(**strings != '\0')
        {
            if(*(*strings)++ == value)//对原来的数据进行了改变
                return 1;
        }
        strings ++;
	}
}
```

**正确的方式**：

```C
int find_char(char **strings,int value)
{
    char *string;
    while((string = *strings) != NULL)//进行备份
    {
        while(*string != '\0')
        {
            if(*string++ == value)
                return 1;
        }
        strings ++;
	}
}
```

## 指针运算

### 算数运算

+ 指针±整数

>  当一个指针和一个整数执行算数运算，整数会在加法运算前根据指针指向的数据类型进行调整,减法会在得到相应的值之后除以指针的类型大小

### 关系运算

前提是必须是一个数组之内的两个值

>  协议允许一个指针和数组之后的那个地址进行比较，但是不允许和之前的那个地址进行比较

```C
  1 #include <stdio.h>                                                                    
  2 #define NUM 5
  3 float values[NUM];
  4 float *vp;
  5 
  6 int main()
  7 {
  8     for( vp = &values[0]; vp <&values[NUM];)
  9         *vp++ = 0;
 10     for( vp = &values[NUM]; vp > &values[0];)
 11         *--vp = 0;
 12     for( vp = &values[NUM-1]; vp >= &values[0];vp--)//这种在有的机器上的运行可能是错误的
 13         *vp = 0;
 14     return 0;
 15 
 16 
 17 }

```























