# 垃圾回收

## Python的机制

### 小整数对象池

Python为了优化速度使用了小整数对象池, 避免整数频繁申请和销毁

Python的[-5, 256]这些整数的对象提前建立好了, 不会被垃圾回收, 在Python里面所有的这一些数据实际使用的是同一个对象, 单个的字母也是这样的

如果是一个字符串, 这一个字符串的引用为0的时候这一个字符串会被回收

### 大整数对象池

每一个大整数实际都是一个新的对象

### 字符串驻留

相同的字符串默认开启intern机制, 指向同一个对象, 字符串里面有空格等特殊字符的时候不会开启这一个机制

## 垃圾回收

Garbage collection垃圾回收, 高级语言里面一般都有自己的回收机制, C语言里面的内存为自己管理的

Python里面有一个自己的回收机制, Python使用自动引用计数（Reference Counting）和循环垃圾回收（Cycle Detection）来实现垃圾回收。

1. 引用计数：Python使用引用计数来跟踪内存中的对象引用数量。当对象被创建时，引用计数会增加；当对象被引用时，引用计数会减少。当引用计数为0时，对象被释放并回收内存。
2. 循环垃圾回收(隔代收集)：虽然引用计数可以处理大部分情况下的内存释放，但是循环引用会导致引用计数失效。当对象之间存在循环引用时，Python会使用循环垃圾回收机制来检测和清理这些无法访问到的对象。

Python里面会有一部分没有办法释放的内存, 所以需要使用GC

### 引用计数的优缺点

+ 优点

1. 简单
2. 实时性没有使用的时候直接释放, 回收的时间平摊在平时

+ 缺点

1. 维护计数消耗资源
2. 无法解决循环引用(多个对象相互记录)

## 零代

Python使用了一个链表记录已经创建了的对象, 这一个链表叫做零代链表

Python会循环遍历这一个链表, 找出里面的相互调用的对象进行统计, 在实际回收的时候, 会把这些循环引用的数值进行减少, 之后把还在使用的对象移动到另一条链子上面

Python里面有一个阈值, 根据创建的对象的个数以及删除的对象的个数进行调用这一个回收机制

## 测试

```python
import gc

class ClassA():
    def __init__(self) -> None:
        print("object born, id %s"%str(id(self)))

def f2():
    while True:
        c1 = ClassA()
        c2 = ClassB()
        c1.t = c2
        c2.t = c1
        del c1
        del c2
# 关闭内存管理
gc.disable()
f2()
```

## 触发条件

1. gc模块达到一个阈值的时候自动回收
2. 使用`gc.collect`手动回收
3. 程序退出, 解释器会回收

## 引用计数变换的条件

+ +1 

1. 对象创建的时候
2. 对象引用的时候
3. 作为参数传入一个函数
4. 作为一个元素记录在容器里面

+ -1

1. 使用del的时候
2. 对象的别名给了他一个新的值
3. 一个对象离开他的作用域
4. 对象所在的容器销毁, 或者从容器里面删除的时候

> 可以使用sys模块里面的`sys.getrefcount()`函数查看这一个对象的引用个数

## 垃圾回收触发机制

python里面使用隔代收集的方法, 对象在创建的时候在一代列表里面, 一代的检查以后进入二代列表, 以此类推, 最多三代列表

可以使用`gc.get_count`获取这一个列表的计数器

```python
In [6]: import gc

In [7]: gc.get_count()
Out[7]: (62, 0, 8)
```

> 这里的62是距离上一次一代检查, python分配减去释放的内存个数, 0是距离上一次二代检查一代检查的次数, 8是二代检查的次数

```python
In [8]: gc.get_threshold()
Out[8]: (700, 10, 10)
```

> 这一个是阈值